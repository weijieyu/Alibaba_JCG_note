一.编程规约

(一)命名风格

1.目录使用小写+下划线 home,view,model,admin_view

2.
类     UpperCamelCase    PhpMailer
方法   lowerCamelCase    getUserName
属性   lowerCamelCase    tableName
函数   小写字母和下划线     get_client_ip 
常量   全部大写  PASSWORD

如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。

(二)代码格式
1.
// 这是示例注释，请注意在双斜线之后有一个空格

2.
if else的语言结构 只在结束的地方换行
e.g.
if (flag == 1) {
    System.out.println("world");
} else {
    System.out.println("ok");

}

3.一行代码不超过120字符，超过需要使用换行
单个方法的总行数不超过 80 行。

4.代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码 更加清晰;共性逻辑抽取成为共性方法，便于复用和维护。

(三)OOP规约
1.所有的覆写方法，必须加@Override注解

2.任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。
如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 
成员方法或成员变量，删除一下，不得手心冒点汗吗

3.避免出现重复的代码(Don’t Repeat Yourself)，即DRY原则

二.安全规约

1.用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，
禁止直接使用前端传来的字符串拼接 SQL 访问数据库。

三.MySQL规约

(一) 建表规约
1.任何字段如果为非负数，必须是 unsigned

2.表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint ( 1表示是，0表示否)

3.表名不使用复数名词，表名应该仅仅表示表里面的实体内容，不应该表示实体数量

4.唯一索引名为 uk_字段名，普通索引名则为 idx_字段名。

5.小数类型为 decimal，禁止使用 float 和 double。
//说明:float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储

6.varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。

7.禁用保留字，如 desc、range、match、delayed  desc//这个很容易误用，以后换成descb

8.表必备三字段:id, gmt_create, gmt_modified。 说明:其中id必为主键，类型为bigint unsigned、单表时自增、步长为1。gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。//here

9.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

(二) 索引规约
1.业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。 说明:不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的;另外，即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律， 必然有脏数据产生。

2.超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致;多表关联查询时，保证被关联的字段需要有索引。

3.利用覆盖索引来进行查询操作，来避免回表操作。
说明:如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?
目录浏览一下就好，这个目录就是起到覆盖索引的作用。 
//这个例子举的非常非常的好，以后用书和目录来理解索引和数据是个非常好的方式
//extra列会出现:using index

4.延迟关联或者子查询优化超多分页场景。
说明:MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么缩减对要放弃的offset行的获取成本。
正例:先快速定位需要获取的 id 段，然后再关联:
SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

5.在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。

6.SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。
说明:
1)consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。 
2)ref 指的是使用普通的索引(normal index)。
3)range 对索引进行范围检索。

7.防止因字段类型不同造成的隐式转换，导致索引失效。
select id from qs_video_update where bid = 73836918995;
select id from qs_video_update where bid = '73836918995';//explain一下天壤之别了

(三)sql语句
1.count(*)就是 SQL92 定义 的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 
说明:count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。






